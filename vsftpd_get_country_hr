#!/usr/bin/perl -T
# Matija Nalis <mnalis-perl@axe.tomsoft.hr> GPLv3+  started 20140405
#
# gets list of RIPE IP adressess and creates ranges for ipset or vsftp pam_access limiting
# upstream: https://github.com/mnalis/pam_access_country_generator
#

use warnings;
use strict;

use POSIX qw(strftime);
use IO::Handle;
use Net::CIDR::Lite;

my $OUR_COUNTRY='HR';	# generate accept list for this country code
my $IPSET_PATH = '/etc';	# where to create ipset.$OUR_COUNTRY.save files (do not save if undef)
my $VSFTPD_FILE_FINAL = '/etc/vsftpd_pam_access.conf';	# (do not save if undef)
my $DEBUG = 0;		# Important! set to 0 for production!
my $IPV4_AS_FFFF=1;	# 0=use "127.0.0.1/32" format for IPv4, 1=use "::ffff:127.0.0.1/128" format for IPv4
my $LINE_PREFIX = '+ : ALL :';	# prepend at the beggining of the line

local $ENV{'PATH'} = '/bin:/usr/bin';

my $IPSET_FILE_FINAL = $IPSET_PATH . '/ipset.' . $OUR_COUNTRY . '.save' if defined $IPSET_PATH;
my $IPSET_FILE_TMP = $IPSET_FILE_FINAL . '.tmp' if defined $IPSET_PATH;

my $DYNAMIC_START = "### AUTOGENERATED RIPE START FOR $OUR_COUNTRY, **DO NOT CHANGE THIS LINE AND AFTER**";
my $DYNAMIC_END   = "### AUTOGENERATED RIPE END FOR $OUR_COUNTRY, **DO NOT CHANGE THIS LINE AND BEFORE**";
my $BUF_SIZE = 300 - length($LINE_PREFIX);	# 8192 - 100 - length($LINE_PREFIX);	# must at least few dozen bytes smaller than system BUFSIZ. it is inexact, so play it safe!
#$BUF_SIZE = 1;	# DEBUG FIXME DELME - for one range per line (for easy diff while debugging)

my $VSFTPD_FILE_TMP = $VSFTPD_FILE_FINAL . '.tmp' if defined $VSFTPD_FILE_FINAL;

my $URLDB='ftp://ftp.ripe.net/pub/stats/ripencc/delegated-ripencc-latest';
my $URLDB_CMD = "wget -q -O- $URLDB";
#$URLDB_CMD = "cat delegated-ripencc-latest";	# DEBUG FIXME DELME - locally cached

my $URLWHOIS6='ftp://ftp.ripe.net/ripe/dbase/split/ripe.db.inet6num.gz';
my $URLWHOIS6_CMD = "wget -q -O- $URLWHOIS6 | gzip -dc";
#$URLWHOIS6_CMD = "zcat ripe.db.inet6num.gz";	# DEBUG FIXME DELME - locally cached

my $URLWHOIS4='ftp://ftp.ripe.net/ripe/dbase/split/ripe.db.inetnum.gz';
my $URLWHOIS4_CMD = "wget -q -O- $URLWHOIS4 | gzip -dc";
#$URLWHOIS4_CMD = "zcat ripe.db.inetnum.gz";	# DEBUG FIXME DELME - locally cached

open (my $f_urldb, '-|', $URLDB_CMD) or die "can't get data from $URLDB_CMD: $!";
open (my $f_url_whois6, '-|', $URLWHOIS6_CMD) or die "can't get data from $URLWHOIS6_CMD: $!";
open (my $f_url_whois4, '-|', $URLWHOIS4_CMD) or die "can't get data from $URLWHOIS4_CMD: $!";

# 2|ripencc|1396648799|85084|19830705|20140404|+0200
my ($db_ver, $db_sig, $db_ts, $db_count, undef, $db_date, $db_tz) = split /\|/, <$f_urldb>;

#  sanity checks
if ("$db_sig$db_ver" ne 'ripencc2') { die "invalid sig/version $db_sig/$db_ver" }

# FIXME: this breaks when month changes, need smarter date handling, but it is not really needed, so remove for now
#my $our_date = strftime "%Y%m%d", localtime;
#if ($db_date < $our_date - 30) { die "database too old: $db_date << $our_date" }

# hardcoded... expect at least  50k of 80k+ in 2014/04
if ($db_count < 50000) { die "$db_count should be > 80000, but is only $db_count" }

$DEBUG and print STDERR "DB ver=$db_ver sig=$db_sig date=$db_date count=$db_count\n";

# base-2 logarithm (to convert number of IP adresses to number of CIDR bits)
sub log2($) {
	my $n=shift;
	return log($n)/log(2);
}

# ensures file reliability
sub fsync($) {
	my ($file) = @_;
    
	$file->flush or die 'fsync cannot flush';
	$file->sync or die 'fsync cannot fsync';
}

my $f_orig;
my $pam_tmp;
if (defined $VSFTPD_FILE_FINAL) {
  open ($f_orig, '<', $VSFTPD_FILE_FINAL) or die "can't read $VSFTPD_FILE_FINAL: $!";
  unlink $VSFTPD_FILE_TMP;
  open ($pam_tmp, '>', $VSFTPD_FILE_TMP) or die "can't write to: $VSFTPD_FILE_TMP: $!";
  # read static content before our dynamic section
  while (<$f_orig>) {
          if (m{^\Q$DYNAMIC_START\E}) { last }
          print $pam_tmp $_  or die "can't write to $VSFTPD_FILE_TMP: $!";;
  }
  print $pam_tmp "$DYNAMIC_START\n" or die "can't write to $VSFTPD_FILE_TMP: $!";
}

my $ipset_tmp;
if (defined $IPSET_PATH) {
  open ($ipset_tmp, '>', $IPSET_FILE_TMP) or die "can't write to: $IPSET_FILE_TMP: $!";
  print $ipset_tmp "create ${OUR_COUNTRY}4 hash:net family inet hashsize 4096 maxelem 65536\n" or die "can't write to $IPSET_FILE_TMP: $!";
  print $ipset_tmp "create ${OUR_COUNTRY}6 hash:net family inet6 hashsize 4096 maxelem 65536\n" or die "can't write to $IPSET_FILE_TMP: $!";
}


my $CIDR4 = Net::CIDR::Lite->new;	# start with empty list of IPv4 ranges
my $CIDR6 = Net::CIDR::Lite->new;	# start with empty list of IPv6 ranges

# print one line
my $char_count = 0;
sub oneline($) {
	my $l = shift;
	
	if (defined $IPSET_PATH) {
	        my $l2 = $l;
	        $l2 =~ s{^::ffff:}{};
	        my $set = $OUR_COUNTRY . (($l2 =~ /:/) ? '6' : '4');
	        print $ipset_tmp "add $set $l2\n"  or die "can't write to $IPSET_FILE_TMP: $!";
	}
	
	if (defined $VSFTPD_FILE_FINAL) {
          if ($char_count == 0) {
                  print $pam_tmp "$LINE_PREFIX " or die "can't write to $VSFTPD_FILE_TMP: $!";
          }
  #	print $pam_tmp "$l\n" or die "can't write to $VSFTPD_FILE_TMP: $!"; return;	# each IP one line

          my $chars = length($l)+1;
          print $pam_tmp "$l " or die "can't write to $VSFTPD_FILE_TMP: $!";
          $char_count += $chars;

          if ($char_count > $BUF_SIZE) {		# break lines next time if we're over $BUF_SIZE chars
                  print $pam_tmp "\n" or die "can't write to $VSFTPD_FILE_TMP: $!";
                  $char_count = 0;
          }
	}
}


#
# read data from RIPE DB (ipv4+ipv6)
#

# lines look like: "ripencc|FR|ipv4|2.0.0.0|1048576|20100712|allocated"
my $count = 0;
while (my $line = <$f_urldb>) {
	my ($l_sig, $l_country, $l_type, $l_ip, $l_size, $l_rest) = split /\|/, $line, 6;
	if ($l_sig ne 'ripencc') { die "invalid signature in line $line" }
	next if $l_country eq '*';	# skip summary lines
	$count++;
	next if $l_type !~ /^ipv[46]$/;	# only interested in IPv4/IPv6
	next if $l_country ne $OUR_COUNTRY;	# not interested in other countries

	my $cidr;
	if ($l_type eq 'ipv6') {	# IPv6
		$cidr = $l_size;
		my $range = "$l_ip/$cidr";
                $CIDR6->add($range);
	} else {			# IPv4
		$cidr = 32-log2($l_size);
		my $range = "$l_ip/$cidr";
                $CIDR4->add($range);
	}
}
close $f_urldb;
# final validity check
if ($count ne $db_count) { die "RIPEDB at $URLDB count mismatch $count != $db_count" }



#
# read data from RIPE IPv6 WHOIS 
#

# example snippet:
#
# inet6num:       2001:6f8::/39
# netname:        EASYNET-GROUP-ALLOC
# descr:          Easynet Group Allocation
# country:        GB
# 

my $last_inetnum = undef;
while (<$f_url_whois6>) {
  if (m{^inet6num:\h*(.+)\h*$}i) {	# inetnum / inet6num
      $last_inetnum = $1;
      die "invalid inet6num: $last_inetnum" if $last_inetnum !~ m{^[a-z0-9/:]+$};
  } elsif (m{^\h*$}) {				# empty line indicates new record
      $last_inetnum = undef;
  } elsif (m{^country:\h*(.+)\h*$}i) {		# country
      my $country = $1;
      die "country $country for undefined inet6num??" if !defined $last_inetnum;
      if ($country =~ m{\b$OUR_COUNTRY\b}i) {	# usually it just 'Country: HR', but it can contain comments and more. So we err on the side of caution (including more than needed)
        #print "$country $last_inetnum\n";
        $CIDR6->add($last_inetnum);
      }
  }
}
close $f_url_whois6;

#
# read data from RIPE IPv4 WHOIS 
#

# example snippet:
#
# inetnum:        80.16.151.184 - 80.16.151.191
# netname:        NETECONOMY-MG41731
# descr:          TELECOM ITALIA LAB SPA
# country:        IT
#

$last_inetnum = undef;
while (<$f_url_whois4>) {
  if (m{^inetnum:\h*(.+)\h*$}i) {	# inetnum / inet6num
      $last_inetnum = $1;
      die "invalid inetnum: $last_inetnum" if $last_inetnum !~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\h*-\h*\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
  } elsif (m{^\h*$}) {				# empty line indicates new record
      $last_inetnum = undef;
  } elsif (m{^country:\h*(.+)\h*$}i) {		# country
      my $country = $1;
      die "country $country for undefined inetnum??" if !defined $last_inetnum;
      if ($country =~ m{\b$OUR_COUNTRY\b}i) {	# usually it just 'Country: HR', but it can contain comments and more. So we err on the side of caution (including more than needed)
        #print "$country $last_inetnum\n";
        $CIDR4->add_range($last_inetnum);
      }
  }
}
close $f_url_whois4;

#
# All data processed. Print all existing ranges to file.
#
foreach my $range ($CIDR4->list) {
        if ($IPV4_AS_FFFF) {
            die "invalid IPv4 range $range" if $range !~ m{([\d\.]+)/(\d+)};
            my $network = $1; my $cidr = $2;
            $cidr += 128-32;
            $range = "::ffff:$network/$cidr";
        }
	oneline ($range);
}
foreach my $range ($CIDR6->list) {
	oneline ($range);
}


if (defined $VSFTPD_FILE_FINAL) {
  # skip dynamic content before static trailer
  while (<$f_orig>) {
          if (m{^\Q$DYNAMIC_END\E}) { last }
  }
  print $pam_tmp "\n$DYNAMIC_END\n" or die "can't write to $VSFTPD_FILE_TMP: $!";

  # add static trailer
  while (<$f_orig>) {
          print $pam_tmp $_;
  }
  close $f_orig;
  fsync($pam_tmp);	# make sure it's safely on disk
  close $pam_tmp or die "can't finish writing to $VSFTPD_FILE_TMP: $!";
  rename $VSFTPD_FILE_TMP, $VSFTPD_FILE_FINAL or die "can't rename $VSFTPD_FILE_TMP to $VSFTPD_FILE_FINAL: $!";
}

if (defined $IPSET_PATH) {
  fsync($ipset_tmp);	# make sure it's safely on disk
  close $ipset_tmp or die "can't finish writing to $IPSET_FILE_TMP: $!";
  rename $IPSET_FILE_TMP, $IPSET_FILE_FINAL or die "can't rename $IPSET_FILE_TMP to $IPSET_FILE_FINAL: $!";
}

$DEBUG and print STDERR "All checks OK\n";
