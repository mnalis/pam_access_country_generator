#!/usr/bin/perl -T
# Matija Nalis <mnalis-perl@axe.tomsoft.hr> GPLv3+  started 20140405
#
# gets list of RIPE IP adressess and creates ranges for vsftp pam_access limiting
# upstream: https://github.com/mnalis/pam_access_country_generator
#

use warnings;
use strict;

use POSIX qw(strftime);
use IO::Handle;
use Net::CIDR qw(cidrvalidate cidradd);

local $ENV{'PATH'} = '/bin:/usr/bin';

my $DEBUG = 0;		# Important! set to 0 for production!
my $OUR_COUNTRY='HR';	# generate accept list for this country code
my $IPV4_AS_FFFF=1;	# 0=use "127.0.0.1/32" format for IPv4, 1=use "::ffff:127.0.0.1/128" format for IPv4
my $LINE_PREFIX = '+ : ALL :';	# prepend at the beggining of the line

my $DYNAMIC_START = "### AUTOGENERATED RIPE START FOR $OUR_COUNTRY, **DO NOT CHANGE THIS LINE AND AFTER**";
my $DYNAMIC_END   = "### AUTOGENERATED RIPE END FOR $OUR_COUNTRY, **DO NOT CHANGE THIS LINE AND BEFORE**";
my $BUF_SIZE = 300 - length($LINE_PREFIX);	# 8192 - 100 - length($LINE_PREFIX);	# must at least few dozen bytes smaller than system BUFSIZ. it is inexact, so play it safe!

my $VSFTPD_FILE_FINAL = 'examples/vsftpd_pam_access.conf';
my $VSFTPD_FILE_TMP = $VSFTPD_FILE_FINAL . '.tmp';

my $URLDB='ftp://ftp.ripe.net/pub/stats/ripencc/delegated-ripencc-latest';
my $URLDB_CMD = "wget -q -O- $URLDB";
$URLDB_CMD = "cat delegated-ripencc-latest";	# DEBUG FIXME DELME

my $URLWHOIS6='ftp://ftp.ripe.net/ripe/dbase/split/ripe.db.inet6num.gz';
my $URLWHOIS6_CMD = "wget -q -O- $URLWHOIS6 | gzip -dc";
$URLWHOIS6_CMD = "zcat ripe.db.inet6num.gz";	# DEBUG FIXME DELME

my $URLWHOIS4='ftp://ftp.ripe.net/ripe/dbase/split/ripe.db.inetnum.gz';
my $URLWHOIS4_CMD = "wget -q -O- $URLWHOIS4 | gzip -dc";
$URLWHOIS4_CMD = "zcat ripe.db.inetnum.gz";	# DEBUG FIXME DELME

open (my $f_urldb, '-|', $URLDB_CMD) or die "can't get data from $URLDB_CMD: $!";
open (my $f_url_whois6, '-|', $URLWHOIS6_CMD) or die "can't get data from $URLWHOIS6_CMD: $!";
open (my $f_url_whois4, '-|', $URLWHOIS4_CMD) or die "can't get data from $URLWHOIS4_CMD: $!";

# 2|ripencc|1396648799|85084|19830705|20140404|+0200
my ($db_ver, $db_sig, $db_ts, $db_count, undef, $db_date, $db_tz) = split /\|/, <$f_urldb>;

#  sanity checks
if ("$db_sig$db_ver" ne 'ripencc2') { die "invalid sig/version $db_sig/$db_ver" }

# FIXME: this breaks when month changes, need smarter date handling, but it is not really needed, so remove for now
#my $our_date = strftime "%Y%m%d", localtime;
#if ($db_date < $our_date - 30) { die "database too old: $db_date << $our_date" }

# hardcoded... expect at least  50k of 80k+ in 2014/04
if ($db_count < 50000) { die "$db_count should be > 80000, but is only $db_count" }

$DEBUG and print STDERR "DB ver=$db_ver sig=$db_sig date=$db_date count=$db_count\n";

# base-2 logarithm (to convert number of IP adresses to number of CIDR bits)
sub log2($) {
	my $n=shift;
	return log($n)/log(2);
}

# ensures file reliability
sub fsync($) {
	my ($file) = @_;
    
	$file->flush or die 'fsync cannot flush';
	$file->sync or die 'fsync cannot fsync';
}

open (my $f_orig, '<', $VSFTPD_FILE_FINAL) or die "can't read $VSFTPD_FILE_FINAL: $!";
unlink $VSFTPD_FILE_TMP;
open (my $f_tmp, '>', $VSFTPD_FILE_TMP) or die "can't write to: $VSFTPD_FILE_TMP: $!";

# read static content before our dynamic section
while (<$f_orig>) {
	if (m{^\Q$DYNAMIC_START\E}) { last }
	print $f_tmp $_  or die "can't write to $VSFTPD_FILE_TMP: $!";;
}
print $f_tmp "$DYNAMIC_START\n" or die "can't write to $VSFTPD_FILE_TMP: $!";

my @CIDRs = ();	# start with empty list of IPv4/IPv6 ranges

# print one line
my $char_count = 0;
sub oneline($) {
	my $l = shift;
	if ($char_count == 0) {
		print $f_tmp "$LINE_PREFIX " or die "can't write to $VSFTPD_FILE_TMP: $!";
	}
#	print $f_tmp "$l\n" or die "can't write to $VSFTPD_FILE_TMP: $!"; return;	# each IP one line

	my $chars = length($l)+1;
	print $f_tmp "$l " or die "can't write to $VSFTPD_FILE_TMP: $!";
	$char_count += $chars;

	if ($char_count > $BUF_SIZE) {		# break lines next time if we're over $BUF_SIZE chars
		print $f_tmp "\n" or die "can't write to $VSFTPD_FILE_TMP: $!";
		$char_count = 0;
	}
}


#
# read data from RIPE DB (ipv4+ipv6)
#

# lines look like: "ripencc|FR|ipv4|2.0.0.0|1048576|20100712|allocated"
my $count = 0;
while (my $line = <$f_urldb>) {
	my ($l_sig, $l_country, $l_type, $l_ip, $l_size, $l_rest) = split /\|/, $line, 6;
	if ($l_sig ne 'ripencc') { die "invalid signature in line $line" }
	next if $l_country eq '*';	# skip summary lines
	$count++;
	next if $l_type !~ /^ipv[46]$/;	# only interested in IPv4/IPv6
	next if $l_country ne $OUR_COUNTRY;	# not interested in other countries

	my $cidr;
	if ($l_type eq 'ipv6') {	# IPv6
		$cidr = $l_size;
	} else {			# IPv4
		if ($IPV4_AS_FFFF) {	
			$cidr = 128-log2($l_size);
			$l_ip = '::ffff:' . $l_ip;
		} else {
			$cidr = 32-log2($l_size);
		}
	}
	my $range = "$l_ip/$cidr";
	die "invalid range $range" if !cidrvalidate($range);
	@CIDRs = cidradd($range, @CIDRs);
}
close $f_urldb;
# final validity check
if ($count ne $db_count) { die "RIPEDB at $URLDB count mismatch $count != $db_count" }



#
# read data from RIPE IPv6 WHOIS 
#

# example snippet:
#
# inet6num:       2001:6f8::/39
# netname:        EASYNET-GROUP-ALLOC
# descr:          Easynet Group Allocation
# country:        GB
# 

my $last_inetnum = undef;
while (<$f_url_whois6>) {
  if (m{^inet6num:\h*(.+)\h*$}i) {	# inetnum / inet6num
      $last_inetnum = $1;
      die "invalid inet6num: $last_inetnum" if $last_inetnum !~ m{^[a-z0-9/:]+$};
  } elsif (m{^\h*$}) {				# empty line indicates new record
      $last_inetnum = undef;
  } elsif (m{^country:\h*(.+)\h*$}i) {		# country
      my $country = $1;
      die "country $country for undefined inet6num??" if !defined $last_inetnum;
      if ($country =~ m{\b$OUR_COUNTRY\b}i) {	# usually it just 'Country: HR', but it can contain comments and more. So we err on the side of caution (including more than needed)
        #print "$country $last_inetnum\n";
        @CIDRs = cidradd($last_inetnum, @CIDRs);
      }
  }
}



#
# All data processed. Print all existing ranges to file.
#
foreach my $range (@CIDRs) {
	oneline ($range);
}

# skip dynamic content before static trailer
while (<$f_orig>) {
	if (m{^\Q$DYNAMIC_END\E}) { last }
}
print $f_tmp "\n$DYNAMIC_END\n" or die "can't write to $VSFTPD_FILE_TMP: $!";

# add static trailer
while (<$f_orig>) {
	print $f_tmp $_;
}

fsync($f_tmp);	# make sure it's safely on disk
close $f_tmp or die "can't finish writing to $VSFTPD_FILE_TMP: $!";
close $f_orig;
rename $VSFTPD_FILE_TMP, $VSFTPD_FILE_FINAL or die "can't rename $VSFTPD_FILE_TMP to $VSFTPD_FILE_FINAL: $!";

$DEBUG and print STDERR "All checks OK\n";
