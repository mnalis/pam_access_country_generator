#!/usr/bin/perl -T
# Matija Nalis <mnalis-perl@axe.tomsoft.hr> GPLv3+  started 20140405 - updated 20190316 
#
# gets list of RIPE IP adressess and creates ranges for ipset or vsftp pam_access limiting
# upstream: https://github.com/mnalis/pam_access_country_generator
#

use warnings;
use strict;

use Getopt::Long;
use Pod::Usage;
use POSIX qw(strftime);
use IO::Handle;
use Net::CIDR::Lite;

my @COUNTRIES = ();		# generate accept list for this country codes
my $PAM_FILE_FINAL = undef;	# (do not save if undef)
my $IPSET_FILE_FINAL = undef;	# (do not save if undef)
my $DEBUG = 0;			# Important! set to 0 for production! 1 for some debug, 9 for using cached files and "." instead of "/etc"
my $IPV4_AS_FFFF=1;		# 0=use "127.0.0.1/32" format for IPv4, 1=use "::ffff:127.0.0.1/128" format for IPv4
my $LINE_PREFIX = '+ : ALL :';	# prepend at the beggining of the line

local $ENV{'PATH'} = '/bin:/usr/bin';

my $BUF_SIZE = 300 - length($LINE_PREFIX);	# 8192 - 100 - length($LINE_PREFIX);	# must at least few dozen bytes smaller than system BUFSIZ. it is inexact, so play it safe!
#$BUF_SIZE = 1;	# DEBUG FIXME DELME - for one range per line (for easy diff while debugging)

my $FASTFILTER = '| grep -F -e inetnum: -e inet6num: -e country:';	# without filter, perl is slower by about factor of 4! (20 vs 72 secs for IPv4, or 4 vs 16 sec for IPv6)

my $DECOMPRESS="gzip -dc";
if ( -x '/usr/bin/pigz') { $DECOMPRESS="pigz -dc" }	# use faster decompressor if available

my $WGET_CMD='curl -s';
if ( -x '/usr/bin/wget') { $WGET_CMD='wget -q -O-' }

# all delegated databases (uses RIPE mirror, should use master for each probably) with estimated mininum of inet(6)nums
my %URLS_DELEGATED = (
		'ftp://ftp.ripe.net/pub/stats/ripencc/delegated-ripencc-latest'		=> 100_000,
		'ftp://ftp.ripe.net/pub/stats/afrinic/delegated-afrinic-latest'		=> 5_000,
		'ftp://ftp.ripe.net/pub/stats/apnic/delegated-apnic-latest' 		=> 50_000,
		'ftp://ftp.ripe.net/pub/stats/lacnic/delegated-lacnic-extended-latest'	=> 30_000,
		'ftp://ftp.arin.net/pub/stats/arin/delegated-arin-extended-latest'	=> 120_000,
	);

# all WHOIS DATABASES
my @URLS_WHOIS = (
		'ftp://ftp.arin.net/pub/rr/arin.db',
		'http://ftp.afrinic.net/dbase/afrinic.db.gz',
		'ftp://ftp.ripe.net/ripe/dbase/split/ripe.db.inet6num.gz',
		'ftp://ftp.ripe.net/ripe/dbase/split/ripe.db.inetnum.gz',
	);

my $opt_help = 0;
my $opt_man = 0;
GetOptions (	'debug|d=i'  => \$DEBUG,
                'country|c=s' => \@COUNTRIES,
                'output-ipset-file=s' => \$IPSET_FILE_FINAL,
                'output-pam-file=s' => \$PAM_FILE_FINAL,
                'ipv4-as-ffff!' => \$IPV4_AS_FFFF,
                'buf-size=i' => \$BUF_SIZE,
                'help|h|?' => \$opt_help,
                'man' => \$opt_man
) or die("Error in command line arguments\n");



pod2usage(1) if $opt_help;
pod2usage(-exitval => 0, -verbose => 2) if $opt_man;

if (!defined $IPSET_FILE_FINAL and !defined $PAM_FILE_FINAL) {
	print STDERR "ERROR: either --output-ipset-file or --output-pam-file must be specified\n";
	exit 2;
}

if (defined $IPSET_FILE_FINAL) {
	if ($IPSET_FILE_FINAL =~ m{^([a-z/_.-]+)$}i) { $IPSET_FILE_FINAL = $1 } else { die "invalid IPSET file specified" }	# untaint
}
if (defined $PAM_FILE_FINAL) {
	if ($PAM_FILE_FINAL   =~ m{^([a-z/_.-]+)$}i) { $PAM_FILE_FINAL = $1 }   else { die "invalid PAM file specified" }	# untaint
}


if (@COUNTRIES) {
	foreach my $country (@COUNTRIES) {
		if ($country =~ /^([A-Z]{2})$/i) { $country=uc($1) } else { die "invalid 2-letter country code $country specified" } 	# untaint
	}
} else {
	print STDERR "ERROR: --country option is mandatory!\n";
	exit 2;
}

my $LABEL = join '_', @COUNTRIES;
my $DYNAMIC_START_R = "### AUTOGENERATED RIPE START";
my $DYNAMIC_START_A = "$DYNAMIC_START_R FOR $LABEL, **DO NOT CHANGE THIS LINE AND AFTER**";
my $DYNAMIC_END_R   = "### AUTOGENERATED RIPE END";
my $DYNAMIC_END_A   = "$DYNAMIC_END_R FOR $LABEL, **DO NOT CHANGE THIS LINE AND BEFORE**";

my $PAM_FILE_TMP = $PAM_FILE_FINAL . '.tmp' if defined $PAM_FILE_FINAL;
my $IPSET_FILE_TMP = $IPSET_FILE_FINAL . '.tmp' if defined $IPSET_FILE_FINAL;


# base-2 logarithm (to convert number of IP adresses to number of CIDR bits)
sub log2($) {
	my $n=shift;
	return log($n)/log(2);
}

# ensures file reliability
sub fsync($) {
	my ($file) = @_;
    
	$file->flush or die 'fsync cannot flush';
	$file->sync or die 'fsync cannot fsync';
}

# returns country found if matched as exact string in our list of countries, eg. 'HR', undef otherwise
sub match_country_exact($) {
	my ($needle_country) = @_;
	foreach my $cur_country (@COUNTRIES) {
		return $cur_country if $needle_country eq $cur_country;
	}
	return undef;
}

# returns country found if matched somewhere in a line, undef otherwise
sub match_country_fuzzy($) {
	my ($haystack_line) = @_;
	foreach my $cur_country (@COUNTRIES) {
	      return $cur_country if ($haystack_line =~ m{\b$cur_country\b}i);	# usually $haystack_line is just 'Country: HR', but it can contain comments and more. So we err on the side of caution (including more than needed)
	}
	return undef;
}

my $f_orig;
my $pam_tmp;
if (defined $PAM_FILE_FINAL) {
  open ($f_orig, '<', $PAM_FILE_FINAL) or die "can't read $PAM_FILE_FINAL: $!";
  unlink $PAM_FILE_TMP;
  open ($pam_tmp, '>', $PAM_FILE_TMP) or die "can't write to: $PAM_FILE_TMP: $!";
  # read static content before our dynamic section
  while (<$f_orig>) {
          if (m{^\Q$DYNAMIC_START_R\E}) { last }
          print $pam_tmp $_  or die "can't write to $PAM_FILE_TMP: $!";;
  }
  print $pam_tmp "$DYNAMIC_START_A\n" or die "can't write to $PAM_FILE_TMP: $!";
}

my $ipset_tmp;
if (defined $IPSET_FILE_FINAL) {
  open ($ipset_tmp, '>', $IPSET_FILE_TMP) or die "can't write to: $IPSET_FILE_TMP: $!";
  foreach my $country (@COUNTRIES) {
	print $ipset_tmp "create ${country}4 hash:net family inet hashsize 4096 maxelem 65536\n"  or die "can't write to $IPSET_FILE_TMP: $!";
	print $ipset_tmp "create ${country}6 hash:net family inet6 hashsize 4096 maxelem 65536\n" or die "can't write to $IPSET_FILE_TMP: $!";
  }
}


my %CCIDR4 = ();	# per-country CIDR IPv4 ranges
my %CCIDR6 = ();	# per-country CIDR IPv6 ranges
foreach my $country (@COUNTRIES) {
	$CCIDR4{$country} = Net::CIDR::Lite->new;	# start with empty list of IPv4 ranges for each country
	$CCIDR6{$country} = Net::CIDR::Lite->new;	# start with empty list of IPv6 ranges for each country
}

# print one line (IPSET and/or PAM)
my $char_count = 0;
sub oneline($$) {
	my ($country, $l) = @_;
	
	if (defined $IPSET_FILE_FINAL) {
	        my $set = $country . (($l =~ /:/) ? '6' : '4');
	        print $ipset_tmp "add $set $l\n"  or die "can't write to $IPSET_FILE_TMP: $!";
	}
	
	if (defined $PAM_FILE_FINAL) {
          if ($IPV4_AS_FFFF and $l =~ m{([\d\.]+)/(\d+)}) {
              my $network = $1; my $cidr = $2;
              $cidr += 128-32;
              $l = "::ffff:$network/$cidr";
          }
          if ($char_count == 0) {
                  print $pam_tmp "$LINE_PREFIX " or die "can't write to $PAM_FILE_TMP: $!";
          }

          my $chars = length($l)+1;
          print $pam_tmp "$l " or die "can't write to $PAM_FILE_TMP: $!";
          $char_count += $chars;

          if ($char_count > $BUF_SIZE) {		# break lines next time if we're over $BUF_SIZE chars
                  print $pam_tmp "\n" or die "can't write to $PAM_FILE_TMP: $!";
                  $char_count = 0;
          }
	}
}


#
# read data from delegated-RIR-latest(-extended) DB (ipv4+ipv6)
#
sub parse_delegated($$) {
	my ($urldb_cmd, $min_count) = @_;
	$DEBUG and print STDERR "Processing delegated DB ($urldb_cmd)\n";
	open (my $f_urldb, '-|', $urldb_cmd) or die "can't get data from $urldb_cmd: $!";

	# Header format:
	# 2|ripencc|1559685599|128918|19830705|20190604|+0200
	# 2|apnic|20190605|61086|19830613|20190604|+1000
	# 2|afrinic|20190605|6213|00000000|20190605|00000
	# 2|lacnic|20190604|34660|19870101|20190604|-0300
	# 2.3|arin|1559710817408|147407|19700101|20190605|-0400
	while (<$f_urldb>) {		# skip leading empty lines and comments
		next if /^\s*$/;
		next if /^\s*#/;
		last;			# first non-empty non-comment line should be our DB header
	}
	my ($db_ver, $db_sig, $db_ts, $db_count, undef, $db_date, $db_tz) = split /\|/;

	# header sanity checks
	if ("$db_sig$db_ver" !~ /^(ripencc|apnic|afrinic|lacnic|arin)2(\.3)?$/) { die "invalid sig/version $db_sig/$db_ver" }

	# FIXME: this breaks when month changes, need smarter date handling, but it is not really needed, so remove for now
	#my $our_date = strftime "%Y%m%d", localtime;
	#if ($db_date < $our_date - 30) { die "database too old: $db_date << $our_date" }

	# hardcoded... expect at least  50k of 80k+ in 2014/04 - FIXME check version/mincount for each RIR (store expectations in %DELEGATED_EXPECT)
	if ($db_count < $min_count) { die "$db_count should be > $min_count, but is only $db_count" }

	$DEBUG and print STDERR "DB ver=$db_ver sig=$db_sig date=$db_date count=$db_count\n";

	# lines look like: "ripencc|FR|ipv4|2.0.0.0|1048576|20100712|allocated"
	# 	  or like: "arin|US|ipv4|192.69.235.0|256|20141117|allocated|b1c3f1f64ba66ec6630c8c7ac597e1cb" (extended format)

	my $count = 0;
	my $count_db4 = 0;
	my $count_db6 = 0;
	while (my $line = <$f_urldb>) {
		my ($l_sig, $l_country, $l_type, $l_ip, $l_size, $l_rest) = split /\|/, $line, 6;
		if ($l_sig ne $db_sig) { die "invalid signature in line $line; $l_sig != $db_sig" }
		next if $l_country eq '*';	# skip summary lines
		$count++;
		next if $l_type !~ /^ipv[46]$/;	# only interested in IPv4/IPv6
		$DEBUG > 12 && print STDERR "    try country: $l_country\n";
		next if !match_country_exact ($l_country);	# not interested in other countries

		my $cidr;
		if ($l_type eq 'ipv6') {	# IPv6
			$cidr = $l_size;
			my $range = "$l_ip/$cidr";
			$DEBUG > 10 && print STDERR "    found $l_ip/$cidr (size: $l_size) in country: $l_country\n";
			$CCIDR6{$l_country}->add($range);
			$count_db6++;
		} else {			# IPv4
			$cidr = 32-log2($l_size);
			if ($cidr - int($cidr)) {
				# FIXME: alternatively, we could just skip over it, and rely on WHOIS4 to fix it. Or we could calculate an range manually and add that to be precise.
				$DEBUG && print STDERR "WARNING: non-CIDR size $l_size for $l_ip/$cidr in country $l_country, upgrading CIDR to bigger one (better be safe than sorry)\n";
				$cidr = int($cidr);	# or we could add "+1" here if we would rather just add partial network range...
			}
			my $range = "$l_ip/$cidr";
			$DEBUG > 10 && print STDERR "    found $l_ip/$cidr (size: $l_size) in country: $l_country\n";
			$CCIDR4{$l_country}->add($range);
			$count_db4++;
		}
	}
	close $f_urldb;
	# final validity check
	if ($count ne $db_count) { die "$db_sig delegated DB count mismatch $count != $db_count" }
	$DEBUG and print STDERR "$db_sig delegated DB finished processing $db_count networks (added $count_db4 IPv4 and $count_db6 IPv6)\n";
}

# if DEBUG>=8, try using cached file if available
sub maybe_try_cached($) {
	my ($url) = @_;
	my $filename = $url; $filename =~ s{^.*/}{}g;

	my $cmd = "$WGET_CMD $url";	# by default, just use wget
	if ($DEBUG > 8) {		# use cached file if possible on DEBUG>=9
		if (-f $filename) {
		        print STDERR "In DEBUG>=9; Using existing cached $filename\n";
			$cmd = "cat $filename";
		}
	}

	if ($filename =~ /inet.?num\.gz$/) {
		$cmd = "$cmd | $DECOMPRESS $FASTFILTER" ;	# if file is compressed SPLIT [inet(6)num-only] WHOIS DB (like ripe.db.inet6num.gz or ripe.db.inetnum.gz), then use FASTFILTER for 400% speedup
	} elsif ($filename =~ /\.gz$/) {
		$cmd = "$cmd | $DECOMPRESS" ;			# otherwise, just uncompress WHOIS file
	}
	$DEBUG > 11 and print STDERR "Using cmd: $cmd";
	return $cmd;
}



# example IPv6 snippet:
#
# inet6num:       2001:6f8::/39
# netname:        EASYNET-GROUP-ALLOC
# descr:          Easynet Group Allocation
# country:        GB
# 
# example IPv4 snippet:
#
# inetnum:        80.16.151.184 - 80.16.151.191
# netname:        NETECONOMY-MG41731
# descr:          TELECOM ITALIA LAB SPA
# country:        IT
#

#
# parses WHOIS IPv4/IPv6 DB
#
sub parse_whois($) {
	my ($whois_cmd) = @_;
	$DEBUG and print STDERR "Processing WHOIS ($whois_cmd)\n";
	open (my $f_url_whois, '-|', $whois_cmd) or die "can't get data from $whois_cmd: $!";
	my $last_inetnum = undef;
	my $last_obj = undef;
	my $new_block = 1;
	my $count_whois4 = 0;
	my $count_whois6 = 0;
	while (<$f_url_whois>) {
		$last_obj = $_ if $new_block;		# first line in new block (after empty line) usually indicates type of object
		if (m{^inet6?num:\h*(.+)\h*$}) {	# inetnum / inet6num
		    $last_inetnum = lc $1;
		    $DEBUG > 12 && print STDERR "  try inet(6)num: $last_inetnum\n";
		    if ($last_inetnum =~ /:/) {
			    die "invalid inet6num: $last_inetnum" if $last_inetnum !~ m{^[a-z0-9/:]+$};
		    } else {
			    die "invalid inetnum: $last_inetnum"  if $last_inetnum !~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\h*-\h*\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
		    }
		} elsif (m{^$}) {				# empty line indicates new record (but line made of whitespace only might be part of descr: in ARIN DB!)
		    $last_inetnum = undef;
		    $last_obj = undef;
		    $new_block = 1;
		    next;
		} elsif (m{^country:\h*(.+)\h*$}) {		# country
		    my $country = $1;
		    $DEBUG > 12 && print STDERR "    try country: $country\n";
		    if (!defined $last_inetnum) {
			    next if defined $last_obj and $last_obj =~ m{^(route|route6|route-set|as-set|aut-num|inet-rtr|key-cert|organisation):};	# known objects which could have "country:" but are not interesting to us
			    die "country $country for undefined inet(6)num and unknown last_obj=$last_obj??";
		    }
		    my $found_country = match_country_fuzzy ($country);	# usually it is just 'Country: HR', but it can contain comments and more. So we err on the side of caution (including more than needed)
		    if ($found_country) {
			$DEBUG > 10 && print STDERR "    found $found_country ($country) $last_inetnum\n";
			if ($last_inetnum =~ /:/) {
				$CCIDR6{$found_country}->add($last_inetnum);
				$count_whois6++;
			} else {
				$CCIDR4{$found_country}->add_range($last_inetnum);
				$count_whois4++;
			}
		    }
		}
		$new_block=0;
	}
	close $f_url_whois;
	$DEBUG and print STDERR "WHOIS added $count_whois4 IPv4 and $count_whois6 IPv6 networks\n";
}

#
# parse delegated RIR db for each RIR
#
foreach my $url_delegated (keys %URLS_DELEGATED) {
	my $urldb_cmd = maybe_try_cached($url_delegated);
	parse_delegated($urldb_cmd, $URLS_DELEGATED{$url_delegated});
}

#
# read data from WHOIS databases for each RIR
#
foreach my $url_whois (@URLS_WHOIS) {
	my $urldb_cmd = maybe_try_cached($url_whois);
	parse_whois($urldb_cmd);
}


#
# All data processed. Print all existing ranges to file.
#
foreach my $country (@COUNTRIES) {
	foreach my $range ($CCIDR4{$country}->list) {
		oneline ($country, $range);
	}
	foreach my $range ($CCIDR6{$country}->list) {
		oneline ($country, $range);
	}
}


if (defined $PAM_FILE_FINAL) {
  # skip dynamic content before static trailer
  while (<$f_orig>) {
          if (m{^\Q$DYNAMIC_END_R\E}) { last }
  }
  print $pam_tmp "\n$DYNAMIC_END_A\n" or die "can't write to $PAM_FILE_TMP: $!";

  # add static trailer
  while (<$f_orig>) {
          print $pam_tmp $_;
  }
  close $f_orig;
  fsync($pam_tmp);	# make sure it's safely on disk
  close $pam_tmp or die "can't finish writing to $PAM_FILE_TMP: $!";
  rename $PAM_FILE_TMP, $PAM_FILE_FINAL or die "can't rename $PAM_FILE_TMP to $PAM_FILE_FINAL: $!";
}

if (defined $IPSET_FILE_FINAL) {
  fsync($ipset_tmp);	# make sure it's safely on disk
  close $ipset_tmp or die "can't finish writing to $IPSET_FILE_TMP: $!";
  rename $IPSET_FILE_TMP, $IPSET_FILE_FINAL or die "can't rename $IPSET_FILE_TMP to $IPSET_FILE_FINAL: $!";
}

$DEBUG and print STDERR "All checks OK\n";

__END__

=head1 NAME

vsftpd_get_country - Generating pam(5) or ipset(8) rulesets for chosen country IPs in RIPE

=head1 SYNOPSIS

vsftpd_get_country [OPTION]...

 Options:

   -c, --country=HR		required, country to generate files for
   --output-ipset-file=s	if specified, output IPSET ruleset to named file. One or more of the output options is required.
   --output-pam-file=s		if specified, output PAM ruleset to named file. One or more of the output options is required.

   -h, --help			brief help message
   --man			full documentation

 Advanced options:

   -d, --debug=0-9		set debug level
   --ipv4-as-ffff		how to specify PAM IPv4 values
   --buf-size=1			set to 1 to not group IPs for PAM

=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=back

=head1 DESCRIPTION

B<vsftpd_get_country> will fetch list of all IPv4 and IPv6 addresses in RIPE
region, and generate ipset(8) and/or pam(5) access list, which you can use
to limit access or usage rights according to originating source IP address.

=head1 COPYRIGHT

Copyright 2014-2019 Matija Nalis.  License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.

This is free software: you are free to change and redistribute it.  There is NO WARRANTY, to the extent permitted by law.

=head1 BUGS

The name B<vsftpd_get_country> is historical misnomer, list of capabilities has improved since its inception.

=head1 SEE ALSO

pam(5), ipset(8)

=cut
