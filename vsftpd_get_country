#!/usr/bin/perl -T
# Matija Nalis <mnalis-perl@axe.tomsoft.hr> GPLv3+  started 20140405 - updated 20190316 
#
# gets list of RIPE IP adressess and creates ranges for ipset or vsftp pam_access limiting
# upstream: https://github.com/mnalis/pam_access_country_generator
#

use warnings;
use strict;

use Getopt::Long;
use Pod::Usage;
use POSIX qw(strftime);
use IO::Handle;
use Net::CIDR::Lite;

my @COUNTRIES = ();		# generate accept list for this country codes
my $PAM_FILE_FINAL = undef;	# (do not save if undef)
my $IPSET_FILE_FINAL = undef;	# (do not save if undef)
my $DEBUG = 0;			# Important! set to 0 for production! 1 for some debug, 9 for using cached files and "." instead of "/etc"
my $IPV4_AS_FFFF=1;		# 0=use "127.0.0.1/32" format for IPv4, 1=use "::ffff:127.0.0.1/128" format for IPv4
my $LINE_PREFIX = '+ : ALL :';	# prepend at the beggining of the line

local $ENV{'PATH'} = '/bin:/usr/bin';

my $BUF_SIZE = 300 - length($LINE_PREFIX);	# 8192 - 100 - length($LINE_PREFIX);	# must at least few dozen bytes smaller than system BUFSIZ. it is inexact, so play it safe!
#$BUF_SIZE = 1;	# DEBUG FIXME DELME - for one range per line (for easy diff while debugging)


my $DECOMPRESS="gzip -dc";
if ( -x '/usr/bin/pigz') { $DECOMPRESS="pigz -dc" }	# use faster decompressor if available

my $FILTER4 = '| grep -F -e inetnum: -e country:';	# without filter, perl takes 74 seconds for WHOIS4, with "grep -F" filter only 20 seconds
my $FILTER6 = '| grep -F -e inet6num: -e country:';	# without filter, perl takes 16 seconds for WHOIS6, with "grep -F" filter only  4 seconds

my $URLDB='ftp://ftp.ripe.net/pub/stats/ripencc/delegated-ripencc-latest';
my $URLDB_CMD = "wget -q -O- $URLDB";
my $URLWHOIS6='ftp://ftp.ripe.net/ripe/dbase/split/ripe.db.inet6num.gz';
my $URLWHOIS6_CMD = "wget -q -O- $URLWHOIS6 | $DECOMPRESS $FILTER6";
my $URLWHOIS4='ftp://ftp.ripe.net/ripe/dbase/split/ripe.db.inetnum.gz';
my $URLWHOIS4_CMD = "wget -q -O- $URLWHOIS4 | $DECOMPRESS $FILTER4";


my $opt_help = 0;
my $opt_man = 0;
GetOptions (	'debug|d=i'  => \$DEBUG,
                'country|c=s' => \@COUNTRIES,
                'output-ipset-file=s' => \$IPSET_FILE_FINAL,
                'output-pam-file=s' => \$PAM_FILE_FINAL,
                'ipv4-as-ffff!' => \$IPV4_AS_FFFF,
                'buf-size=i' => \$BUF_SIZE,
                'help|h|?' => \$opt_help,
                'man' => \$opt_man
) or die("Error in command line arguments\n");

if ($DEBUG > 8) {
	if (-f 'delegated-ripencc-latest') {
		$URLDB_CMD = "cat delegated-ripencc-latest";
	        print STDERR "In DEBUG>=9; Using existing cached URLDB_CMD=$URLDB_CMD\n";
	}
	if (-f 'ripe.db.inet6num.gz') {
	        $URLWHOIS6_CMD = "$DECOMPRESS ripe.db.inet6num.gz $FILTER6";
	        print STDERR "In DEBUG>=9; Using existing cached URLWHOIS6_CMD=$URLWHOIS6_CMD\n";
        }
	if (-f 'ripe.db.inetnum.gz') {
	        $URLWHOIS4_CMD = "$DECOMPRESS ripe.db.inetnum.gz $FILTER4";
	        print STDERR "In DEBUG>=9; Using existing cached URLWHOIS4_CMD=$URLWHOIS4_CMD\n";
	}
}

pod2usage(1) if $opt_help;
pod2usage(-exitval => 0, -verbose => 2) if $opt_man;

if (!defined $IPSET_FILE_FINAL and !defined $PAM_FILE_FINAL) {
	print STDERR "ERROR: either --output-ipset-file or --output-pam-file must be specified\n";
	exit 2;
}

if (defined $IPSET_FILE_FINAL) {
	if ($IPSET_FILE_FINAL =~ m{^([a-z/_.-]+)$}i) { $IPSET_FILE_FINAL = $1 } else { die "invalid IPSET file specified" }	# untaint
}
if (defined $PAM_FILE_FINAL) {
	if ($PAM_FILE_FINAL =~ m{^([a-z/_.-]+)$}i) { $PAM_FILE_FINAL = $1 } else { die "invalid PAM file specified" }		# untaint
}


if (@COUNTRIES) {
	foreach my $country (@COUNTRIES) {
		if ($country =~ /^([A-Z]{2})$/i) { $country=uc($1) } else { die "invalid 2-letter country code $country specified" } 	# untaint
	}
} else {
	print STDERR "ERROR: --country option is mandatory!\n";
	exit 2;
}

my $LABEL = join '_', @COUNTRIES;
my $DYNAMIC_START_R = "### AUTOGENERATED RIPE START";
my $DYNAMIC_START_A = "$DYNAMIC_START_R FOR $LABEL, **DO NOT CHANGE THIS LINE AND AFTER**";
my $DYNAMIC_END_R   = "### AUTOGENERATED RIPE END";
my $DYNAMIC_END_A   = "$DYNAMIC_END_R FOR $LABEL, **DO NOT CHANGE THIS LINE AND BEFORE**";

my $PAM_FILE_TMP = $PAM_FILE_FINAL . '.tmp' if defined $PAM_FILE_FINAL;
my $IPSET_FILE_TMP = $IPSET_FILE_FINAL . '.tmp' if defined $IPSET_FILE_FINAL;


open (my $f_urldb, '-|', $URLDB_CMD) or die "can't get data from $URLDB_CMD: $!";
open (my $f_url_whois6, '-|', $URLWHOIS6_CMD) or die "can't get data from $URLWHOIS6_CMD: $!";
open (my $f_url_whois4, '-|', $URLWHOIS4_CMD) or die "can't get data from $URLWHOIS4_CMD: $!";

# 2|ripencc|1396648799|85084|19830705|20140404|+0200
my ($db_ver, $db_sig, $db_ts, $db_count, undef, $db_date, $db_tz) = split /\|/, <$f_urldb>;

#  sanity checks
if ("$db_sig$db_ver" ne 'ripencc2') { die "invalid sig/version $db_sig/$db_ver" }

# FIXME: this breaks when month changes, need smarter date handling, but it is not really needed, so remove for now
#my $our_date = strftime "%Y%m%d", localtime;
#if ($db_date < $our_date - 30) { die "database too old: $db_date << $our_date" }

# hardcoded... expect at least  50k of 80k+ in 2014/04
if ($db_count < 50000) { die "$db_count should be > 80000, but is only $db_count" }

$DEBUG and print STDERR "DB ver=$db_ver sig=$db_sig date=$db_date count=$db_count\n";

# base-2 logarithm (to convert number of IP adresses to number of CIDR bits)
sub log2($) {
	my $n=shift;
	return log($n)/log(2);
}

# ensures file reliability
sub fsync($) {
	my ($file) = @_;
    
	$file->flush or die 'fsync cannot flush';
	$file->sync or die 'fsync cannot fsync';
}

# returns country found if matched as exact string in our list of countries, eg. 'HR', undef otherwise
sub match_country_exact($) {
	my ($needle_country) = @_;
	foreach my $cur_country (@COUNTRIES) {
		return $cur_country if $needle_country eq $cur_country;
	}
	return undef;
}

# returns country found if matched somewhere in a line, undef otherwise
sub match_country_fuzzy($) {
	my ($haystack_line) = @_;
	foreach my $cur_country (@COUNTRIES) {
	      return $cur_country if ($haystack_line =~ m{\b$cur_country\b}i);	# usually $haystack_line is just 'Country: HR', but it can contain comments and more. So we err on the side of caution (including more than needed)
	}
	return undef;
}

my $f_orig;
my $pam_tmp;
if (defined $PAM_FILE_FINAL) {
  open ($f_orig, '<', $PAM_FILE_FINAL) or die "can't read $PAM_FILE_FINAL: $!";
  unlink $PAM_FILE_TMP;
  open ($pam_tmp, '>', $PAM_FILE_TMP) or die "can't write to: $PAM_FILE_TMP: $!";
  # read static content before our dynamic section
  while (<$f_orig>) {
          if (m{^\Q$DYNAMIC_START_R\E}) { last }
          print $pam_tmp $_  or die "can't write to $PAM_FILE_TMP: $!";;
  }
  print $pam_tmp "$DYNAMIC_START_A\n" or die "can't write to $PAM_FILE_TMP: $!";
}

my $ipset_tmp;
if (defined $IPSET_FILE_FINAL) {
  open ($ipset_tmp, '>', $IPSET_FILE_TMP) or die "can't write to: $IPSET_FILE_TMP: $!";
  foreach my $country (@COUNTRIES) {
	print $ipset_tmp "create ${country}4 hash:net family inet hashsize 4096 maxelem 65536\n" or die "can't write to $IPSET_FILE_TMP: $!";
	print $ipset_tmp "create ${country}6 hash:net family inet6 hashsize 4096 maxelem 65536\n" or die "can't write to $IPSET_FILE_TMP: $!";
  }
}


my %CCIDR4 = ();	# per-country CIDR IPv4 ranges
my %CCIDR6 = ();	# per-country CIDR IPv6 ranges
foreach my $country (@COUNTRIES) {
	$CCIDR4{$country} = Net::CIDR::Lite->new;	# start with empty list of IPv4 ranges
	$CCIDR6{$country} = Net::CIDR::Lite->new;	# start with empty list of IPv6 ranges
}

# print one line
my $char_count = 0;
sub oneline($$) {
	my ($country, $l) = @_;
	
	if (defined $IPSET_FILE_FINAL) {
	        my $set = $country . (($l =~ /:/) ? '6' : '4');
	        print $ipset_tmp "add $set $l\n"  or die "can't write to $IPSET_FILE_TMP: $!";
	}
	
	if (defined $PAM_FILE_FINAL) {
          if ($IPV4_AS_FFFF and $l =~ m{([\d\.]+)/(\d+)}) {
              my $network = $1; my $cidr = $2;
              $cidr += 128-32;
              $l = "::ffff:$network/$cidr";
          }
          if ($char_count == 0) {
                  print $pam_tmp "$LINE_PREFIX " or die "can't write to $PAM_FILE_TMP: $!";
          }

          my $chars = length($l)+1;
          print $pam_tmp "$l " or die "can't write to $PAM_FILE_TMP: $!";
          $char_count += $chars;

          if ($char_count > $BUF_SIZE) {		# break lines next time if we're over $BUF_SIZE chars
                  print $pam_tmp "\n" or die "can't write to $PAM_FILE_TMP: $!";
                  $char_count = 0;
          }
	}
}


#
# read data from RIPE DB (ipv4+ipv6)
#

# lines look like: "ripencc|FR|ipv4|2.0.0.0|1048576|20100712|allocated"
my $count = 0;
my $count_db4 = 0;
my $count_db6 = 0;
while (my $line = <$f_urldb>) {
	my ($l_sig, $l_country, $l_type, $l_ip, $l_size, $l_rest) = split /\|/, $line, 6;
	if ($l_sig ne 'ripencc') { die "invalid signature in line $line" }
	next if $l_country eq '*';	# skip summary lines
	$count++;
	next if $l_type !~ /^ipv[46]$/;	# only interested in IPv4/IPv6
	$DEBUG > 12 && print STDERR "    try country: $l_country\n";
	next if !match_country_exact ($l_country);	# not interested in other countries

	my $cidr;
	if ($l_type eq 'ipv6') {	# IPv6
		$cidr = $l_size;
		my $range = "$l_ip/$cidr";
		$DEBUG > 10 && print STDERR "    found $l_ip/$cidr (size: $l_size) in country: $l_country\n";
                $CCIDR6{$l_country}->add($range);
		$count_db6++;
	} else {			# IPv4
		$cidr = 32-log2($l_size);
		if ($cidr - int($cidr)) {
			# FIXME: alternatively, we could just skip over it, and rely on WHOIS4 to fix it. Or we could calculate an range manually and add that to be precise.
			$DEBUG && print STDERR "WARNING: non-CIDR size $l_size for $l_ip/$cidr in country $l_country, upgrading CIDR to bigger one (better be safe than sorry)\n";
			$cidr = int($cidr);	# or we could add "+1" here if we would rather just add partial network range...
		}
		my $range = "$l_ip/$cidr";
		$DEBUG > 10 && print STDERR "    found $l_ip/$cidr (size: $l_size) in country: $l_country\n";
                $CCIDR4{$l_country}->add($range);
		$count_db4++;
	}
}
close $f_urldb;
# final validity check
if ($count ne $db_count) { die "RIPEDB at $URLDB count mismatch $count != $db_count" }
$DEBUG and print STDERR "RIPE DB finished processing $db_count networks (added $count_db4 IPv4 and $count_db6 IPv6)\n";



#
# read data from RIPE IPv6 WHOIS 
#

# example snippet:
#
# inet6num:       2001:6f8::/39
# netname:        EASYNET-GROUP-ALLOC
# descr:          Easynet Group Allocation
# country:        GB
# 

$DEBUG and print STDERR "Processing WHOIS6\n";
my $last_inetnum = undef;
my $count_whois6 = 0;
while (<$f_url_whois6>) {
  if (m{^inet6num:\h*(.+)\h*$}) {	# inetnum / inet6num
      $last_inetnum = $1;
      $DEBUG > 12 && print STDERR "  try6 inet6num: $last_inetnum\n";
      die "invalid inet6num: $last_inetnum" if $last_inetnum !~ m{^[a-z0-9/:]+$};
  } elsif (m{^\h*$}) {				# empty line indicates new record
      $last_inetnum = undef;
  } elsif (m{^country:\h*(.+)\h*$}) {		# country
      my $country = $1;
      $DEBUG > 12 && print STDERR "    try6 country: $country\n";
      die "country $country for undefined inet6num??" if !defined $last_inetnum;
      my $found_country = match_country_fuzzy ($country);	# usually it just 'Country: HR', but it can contain comments and more. So we err on the side of caution (including more than needed)
      if ($found_country) {
        $DEBUG > 10 && print STDERR "    found6 $found_country ($country) $last_inetnum\n";
        $CCIDR6{$found_country}->add($last_inetnum);
	$count_whois6++;
      }
  }
}
close $f_url_whois6;
$DEBUG and print STDERR "WHOIS6 added $count_whois6 networks\n";


#
# read data from RIPE IPv4 WHOIS 
#

# example snippet:
#
# inetnum:        80.16.151.184 - 80.16.151.191
# netname:        NETECONOMY-MG41731
# descr:          TELECOM ITALIA LAB SPA
# country:        IT
#

$DEBUG and print STDERR "Processing WHOIS4\n";
$last_inetnum = undef;
my $count_whois4 = 0;
while (<$f_url_whois4>) {
  if (m{^inetnum:\h*(.+)\h*$}) {	# inetnum / inet6num
      $last_inetnum = $1;
      $DEBUG > 12 && print STDERR "  try4 inetnum: $last_inetnum\n";
      die "invalid inetnum: $last_inetnum" if $last_inetnum !~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\h*-\h*\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
  } elsif (m{^\h*$}) {				# empty line indicates new record
      $last_inetnum = undef;
  } elsif (m{^country:\h*(.+)\h*$}) {		# country
      my $country = $1;
      $DEBUG > 12 && print STDERR "    try4 country: $country\n";
      die "country $country for undefined inetnum??" if !defined $last_inetnum;
      my $found_country = match_country_fuzzy ($country);	# usually it just 'Country: HR', but it can contain comments and more. So we err on the side of caution (including more than needed)
      if ($found_country) {
        $DEBUG > 10 && print STDERR "    found4 $found_country ($country) $last_inetnum\n";
        $CCIDR4{$found_country}->add_range($last_inetnum);
	$count_whois4++;
      }
  }
}
close $f_url_whois4;
$DEBUG and print STDERR "WHOIS4 added $count_whois4 networks\n";


#
# All data processed. Print all existing ranges to file.
#
foreach my $country (@COUNTRIES) {
	foreach my $range ($CCIDR4{$country}->list) {
		oneline ($country, $range);
	}
	foreach my $range ($CCIDR6{$country}->list) {
		oneline ($country, $range);
	}
}


if (defined $PAM_FILE_FINAL) {
  # skip dynamic content before static trailer
  while (<$f_orig>) {
          if (m{^\Q$DYNAMIC_END_R\E}) { last }
  }
  print $pam_tmp "\n$DYNAMIC_END_A\n" or die "can't write to $PAM_FILE_TMP: $!";

  # add static trailer
  while (<$f_orig>) {
          print $pam_tmp $_;
  }
  close $f_orig;
  fsync($pam_tmp);	# make sure it's safely on disk
  close $pam_tmp or die "can't finish writing to $PAM_FILE_TMP: $!";
  rename $PAM_FILE_TMP, $PAM_FILE_FINAL or die "can't rename $PAM_FILE_TMP to $PAM_FILE_FINAL: $!";
}

if (defined $IPSET_FILE_FINAL) {
  fsync($ipset_tmp);	# make sure it's safely on disk
  close $ipset_tmp or die "can't finish writing to $IPSET_FILE_TMP: $!";
  rename $IPSET_FILE_TMP, $IPSET_FILE_FINAL or die "can't rename $IPSET_FILE_TMP to $IPSET_FILE_FINAL: $!";
}

$DEBUG and print STDERR "All checks OK\n";

__END__

=head1 NAME

vsftpd_get_country - Generating pam(5) or ipset(8) rulesets for chosen country IPs in RIPE

=head1 SYNOPSIS

vsftpd_get_country [OPTION]...

 Options:

   -c, --country=HR		required, country to generate files for
   --output-ipset-file=s	if specified, output IPSET ruleset to named file. One or more of the output options is required.
   --output-pam-file=s		if specified, output PAM ruleset to named file. One or more of the output options is required.

   -h, --help			brief help message
   --man			full documentation

 Advanced options:

   -d, --debug=0-9		set debug level
   --ipv4-as-ffff		how to specify PAM IPv4 values
   --buf-size=1			set to 1 to not group IPs for PAM

=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=back

=head1 DESCRIPTION

B<vsftpd_get_country> will fetch list of all IPv4 and IPv6 addresses in RIPE
region, and generate ipset(8) and/or pam(5) access list, which you can use
to limit access or usage rights according to originating source IP address.

=head1 COPYRIGHT

Copyright 2014-2019 Matija Nalis.  License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.

This is free software: you are free to change and redistribute it.  There is NO WARRANTY, to the extent permitted by law.

=head1 BUGS

The name B<vsftpd_get_country> is historical misnomer, list of capabilities has improved since its inception.

=head1 SEE ALSO

pam(5), ipset(8)

=cut
